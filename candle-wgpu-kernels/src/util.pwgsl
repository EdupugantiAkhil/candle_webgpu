#ifdef f32
#define DTYPE f32 
#endif

#ifdef u32
#define DTYPE u32 
#endif

#ifdef u8
#define DTYPE u32 
#endif

@group(0) @binding(0)
var<storage, read_write> v_dest: array<DTYPE>;

@group(0) @binding(1)
var<storage> op_meta : array<u32>;

@group(0) @binding(2)
var<storage> v_input1: array<DTYPE>;

@group(0) @binding(3)
var<storage> v_input2: array<DTYPE>;

@group(0) @binding(4)
var<storage> v_input3: array<DTYPE>;

@group(0) @binding(0)
var<storage, read_write> v_dest_u32: array<u32>;

@group(0) @binding(0)
var<storage, read_write> v_dest_f32: array<f32>;

@group(0) @binding(2)
var<storage> v_input1_u32: array<u32>;


const ZERO : DTYPE = 0;
const ONE : DTYPE = 1;

#ifdef f32
const MINVALUE : f32 = -3.40282e+38;
#else
const MINVALUE : DTYPE = 0;
#endif

struct MatrixIndex{
    id : u32,
    is_valid : bool
}

fn get_index(input_offset : u32, index : u32) -> MatrixIndex{
    let dims = op_meta[input_offset];
    let start_offset = op_meta[input_offset + 1];
    let length = op_meta[input_offset + 2]; 

    //contigues:
    if(length > 0){
        if index < length{
            return MatrixIndex((start_offset + index), true);
        }
        return MatrixIndex(0, false);
    }

    let start_shape_offset = input_offset + 3;

    var shapes_i = 1u;
    var new_index = start_offset;    
    for (var i2 : i32 = i32(dims) - 1; i2 >= 0; i2--){
        let i = u32(i2);
        let prev_shapes_i = shapes_i;
        shapes_i *= op_meta[start_shape_offset + i]; 

        let si = (index / prev_shapes_i) % (shapes_i / prev_shapes_i);  
        new_index += si * op_meta[start_shape_offset + dims + i]; //s_i * stride_i
    }

    if index >= shapes_i{ //in shapes_i is the length after the for loop
        return MatrixIndex(0, false);
    }

    return MatrixIndex(new_index, true);
}

fn get_size(input_offset : u32) -> u32{
    let dims = op_meta[input_offset];
    return dims * 2 + 3;
}