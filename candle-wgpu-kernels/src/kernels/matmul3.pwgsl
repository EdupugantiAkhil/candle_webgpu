#include "util.pwgsl"


override CONSTV_0 : u32 = 1u;
override CONSTV_1 : u32 = 1u;
override CONSTV_2 : u32 = 1u;
override CONSTV_3 : u32 = 1u;
override CONSTV_4 : bool = true;

#define op_matmul.input1_stride_k   CONSTV_0
#define op_matmul.input1_stride_m   CONSTV_1

#define op_matmul.input2_stride_n   CONSTV_2
#define op_matmul.input2_stride_k   CONSTV_3

#define op_matmul.use_batch   CONSTV_4

#define op_matmul.b                 op_meta[0]
#define op_matmul.m                 op_meta[1]
#define op_matmul.k                 op_meta[2]
#define op_matmul.n                 op_meta[3]

#define op_matmul.input1_stride_b   op_meta[4]
#define op_matmul.input1_offset     op_meta[5]

#define op_matmul.input2_stride_b   op_meta[6]
#define op_matmul.input2_offset     op_meta[7]

#define op_matmul.gx_offset     op_meta[8]
#define op_matmul.gy_offset     op_meta[9]

//const RTRS : u32 = 2u;
//const TS1 : u32 = 16u;

const TSM : u32 = 64u;                // The tile-size in dimension M
const TSN : u32 = 64u;                // The tile-size in dimension N
const TSK : u32 = 16u;                 // The tile-size in dimension K
const WPTM : u32 = 4u;                 // The work-per-thread in dimension M
const WPTN : u32 = 4u;                 // The work-per-thread in dimension N
const RTSM : u32 = (TSM/WPTM); //16        // The reduced tile-size in dimension M
const RTSN : u32 = (TSN/WPTN); //16       // The reduced tile-size in dimension N
const LPTA : u32 = ((TSK*TSM)/(RTSM*RTSN)); //8 Loads-per-thread for A
const LPTB : u32 = ((TSK*TSN)/(RTSM*RTSN)); //8 Loads-per-thread for B

//#define RTRS 2u
//#define TS1 16u

var<workgroup> Asub: array<array<DTYPE, TSM>, TSK>;
var<workgroup> Bsub: array<array<DTYPE, TSN>, TSK>;

@compute @workgroup_size(RTSN, RTSM, 1)
//MxK * KxN = MxN
fn matmul5(@builtin(workgroup_id) group_id: vec3<u32>, @builtin(local_invocation_id) local_id: vec3<u32>) {
    let lx = local_id.x * WPTN;
    let ly = local_id.y * WPTM;

    let gx = TSN*group_id.x + lx;
    let gy = TSM*group_id.y + ly;
   
    let batch = group_id.z;

    let output_size_of_one_batch = select(op_matmul.use_batch, op_matmul.m * op_matmul.n, 0u); 

    let input1_offset = op_matmul.input1_offset;
    let input2_offset = op_matmul.input2_offset;

    let input1_stride_b = select(op_matmul.use_batch, op_matmul.input1_stride_b, 0u); 
    let input2_stride_b = select(op_matmul.use_batch, op_matmul.input2_stride_b, 0u); 

    let m_input1_offset = input1_offset + op_matmul.input1_stride_m * TSM * group_id.y + batch * input1_stride_b;
    let m_input2_offset = input2_offset + op_matmul.input2_stride_n * TSN * group_id.x + batch * input2_stride_b;

    let max_k = op_matmul.k;

    var a_reg = ZERO;
    var b_reg = array<DTYPE, WPTN>();
    var acc = array<array<DTYPE, WPTN>, WPTM>();

    let tid = (local_id.y*RTSN + local_id.x) * LPTA;

    for(var t = 0u; t < max_k; t+=TSK){
        let t_offset1 = m_input1_offset + t * op_matmul.input1_stride_k;
        let t_offset2 = m_input2_offset + t * op_matmul.input2_stride_k;

        for(var la = 0u; la < LPTA; la += 1u){
            let id = la + tid;
            let id0_128 = id % TSM;
            let id0_16 = id / TSM;

            Asub[id0_16][id0_128] = v_input1[t_offset1 + id0_16 * op_matmul.input1_stride_k + id0_128 * op_matmul.input1_stride_m];
            Bsub[id0_16][id0_128] = v_input2[t_offset2 + id0_16 * op_matmul.input2_stride_k + id0_128 * op_matmul.input2_stride_n];
        }

        // for(var w = 0u; w < WPT1; w++){
        //     Asub[lx + w][ly] = v_input1[t_offset1 + w * op_matmul.input1_stride_k];
        //     Bsub[ly][lx + w] = v_input2[t_offset2 + w * op_matmul.input2_stride_n];
        // }
        workgroupBarrier();
        
        // Loop over the values of a single tile
        for (var k=0u; k<TSK; k++) {

            // Cache the values of Bsub in registers
            for (var wn=0u; wn<WPTN; wn++) {
                b_reg[wn] = Bsub[k][lx + wn];
            }

            // Perform the computation
            for (var wm=0u; wm<WPTM; wm++) {
                a_reg = Asub[k][ly + wm];
                for (var wn=0u; wn<WPTN; wn++) {
                    acc[wm][wn] += a_reg * b_reg[wn];
                }
            }
        }

        // for(var k = 0u; k < TSK; k++){
        //     let a = Asub[k][ly];
        //     for(var w = 0u; w < WPT1; w++){
        //         acc[w] += a*Bsub[k][lx + w];
        //     }
        // }

        workgroupBarrier();
    }
    
    
    let dest_index = batch * output_size_of_one_batch + gy * op_matmul.n + gx;
    // Store the final results in C
    for (var wm=0u; wm<WPTM; wm++) {
        let globalRow = dest_index + wm * N;
        for (var wn=0u; wn<WPTN; wn++) {
            var globalCol = globalRow + wn;
            v_dest[globalCol] = acc[wm][wn];
        }
    }

    
    // for(var w = 0u; w < WPT1; w++){
    //     v_dest[dest_index + w] = acc[w];
    // }
}