#include "util.pwgsl"

// #ifdef f32
// #define DTYPE f32 
// #endif

// #ifdef u32
// #define DTYPE u32 
// #endif

// #ifdef u8
// #define DTYPE u32 
// #endif

// @group(0) @binding(0)
// var<storage, read_write> v_dest: array<DTYPE>;

// @group(0) @binding(1)
// var<storage> op_meta : array<u32>;

// @group(0) @binding(2)
// var<storage> v_input1: array<DTYPE>;

// @group(0) @binding(3)
// var<storage> v_input2: array<DTYPE>;

// const ZERO : DTYPE = 0;
// const ONE : DTYPE = 1;

// #ifdef f32
// const MINVALUE : f32 = -3.40282e+38;
// #endif


override CONSTV_0 : u32 = 1u;
override CONSTV_1 : u32 = 1u;

#define op_softmax.workgroup_count             CONSTV_0
#define op_softmax.input1_offset               CONSTV_1

//#define op_softmax.workgroup_count              op_meta[0]
#define op_softmax.workgroup_size               op_meta[0]
#define op_softmax.length                       op_meta[1]
//#define op_softmax.input1_offset                op_meta[3]
#define op_softmax.dest_size                    op_meta[2]

var<workgroup> sharedSums: array<DTYPE, 64>; 

var<workgroup> sharedM: f32; 

#ifdef f32



@compute
@workgroup_size(64,1,1)
fn softmax(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let workgroup_id = global_id.x;
    let output_index = global_id.y + global_id.z * 65535;
    
    //Start Index of the Elements to Reduce
    let length = op_softmax.length; //length of the elements to reduce
    let start_index = output_index * length;
    let start_index1 = start_index + op_softmax.input1_offset;

    //We split the Reduction into 64 threads -> find the sub region we need to reduce over 
    let start = workgroup_id * op_softmax.workgroup_size;
    let end = min(length, (workgroup_id + 1) * op_softmax.workgroup_size);

    if(output_index < op_softmax.dest_size)
    {
        //Now Reduce from start to end
        var sum = MINVALUE;
        for (var i = start; i < end; i++){
            let v = v_input1[start_index1 + i];
            sum = max(sum,v);
        }
        sharedSums[workgroup_id] = sum; 
    }
    workgroupBarrier();
    //calculate max
    if (workgroup_id == 0 && output_index < op_softmax.dest_size){
        let cnt = op_softmax.workgroup_count;
        //Finnaly Sum of all worker threads:
        var sum = MINVALUE;
        for (var i = 0u; i < cnt; i++){
            sum = max(sum,sharedSums[i]) ;
        }

        sharedM = sum;
    }

    workgroupBarrier();
    if (output_index < op_softmax.dest_size) {
         for (var i = start; i < end; i++){
            v_dest[start_index + i] = exp(v_input1[start_index1 + i] - sharedM);
        }

        //Now Calculate Sum:
        var sum = ZERO;
        for (var i = start; i < end; i++){
            let v = v_dest[start_index + i];
            sum += v;
        }
        sharedSums[workgroup_id] = sum;
    }
   
    workgroupBarrier();

    if (workgroup_id == 0 && output_index < op_softmax.dest_size){
        let cnt = op_softmax.workgroup_count;
        //Finnaly Sum of all worker threads:
        var sum = ZERO;
        for (var i = 0u; i < cnt; i++){
            sum +=  sharedSums[i];
        }

        sharedM = sum;
    }

    workgroupBarrier();
    if (output_index < op_softmax.dest_size) {
        for (var i = start; i < end; i++){
            v_dest[start_index + i] = v_dest[start_index + i] / sharedM;
        }
    }
}

#endif