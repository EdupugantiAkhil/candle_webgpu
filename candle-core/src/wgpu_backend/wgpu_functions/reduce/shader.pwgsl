#include "../util.pwgsl"

struct MetaInfoReduce{
    input_layout : MatrixLayout,
    operation : u32,
    workgroup_count : u32,
    workgroup_size : u32,
    length : u32, //Length of Reduction(e.g count of elements to sum per output),

    output_to_start_stride1 : u32, //Stride between each new Output Index
    
    output_to_start_shape_stride2 : u32, //After x Outputs use Stride 2 
    output_to_start_stride2 : u32,

    stride_reduction : u32, //The Stride to use for elements in Reduction
}

@group(0) @binding(1)
var<uniform> op_reduce : MetaInfoReduce;

var<workgroup> sharedSums: array<DTYPE, 64>; 
var<workgroup> sharedIndex: array<u32, 64>; 

@compute
@workgroup_size(64,1,1)
fn reduce(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let workgroup_id = global_id.x;
    let output_index = global_id.y;
    
    //Start Index of the Elements to Reduce

    var start_index = 0u;// = output_index * op_reduce.output_to_start_stride1 + (output_index / op_reduce.output_to_start_shape_stride2) * op_reduce.output_to_start_stride2;
    if op_reduce.output_to_start_shape_stride2 <= 1
    {
        start_index = output_index * op_reduce.output_to_start_stride1;
    }
    else{
        start_index = output_index * op_reduce.output_to_start_stride1 + (output_index / op_reduce.output_to_start_shape_stride2) * op_reduce.output_to_start_stride2;
    }
    
    let length = op_reduce.length; //length of the elements to reduce

    //We split the Reduction into 64 threads -> find the sub region we need to reduce over 
    let start = workgroup_id * op_reduce.workgroup_size;
    let end = min(length, (workgroup_id + 1) * op_reduce.workgroup_size);

    //Now Reduce from start to end
    switch(op_reduce.operation){
        case 0u{ //sum
            var sum = ZERO;
            for (var i = start; i < end; i++){
                let index = get_index(op_reduce.input_layout, start_index + i * op_reduce.stride_reduction).id;
                sum += v_input1[index];
            }
            sharedSums[workgroup_id] = sum;
        }
        case 1u{ //min
            var sum = v_input1[get_index(op_reduce.input_layout, start_index).id];
            for (var i = start + 1; i < end; i++){
                let index = get_index(op_reduce.input_layout, start_index + i * op_reduce.stride_reduction).id;
                sum = min(sum, v_input1[index]);
            }
            sharedSums[workgroup_id] = sum;
        }
        case 2u{ //max
            var sum = v_input1[get_index(op_reduce.input_layout, start_index).id];
            for (var i = start + 1; i < end; i++){
                let index = get_index(op_reduce.input_layout, start_index + i * op_reduce.stride_reduction).id;
                sum = max(sum, v_input1[index]);
            }
            sharedSums[workgroup_id] = sum;
        }
        default{

        }
    }
    
    workgroupBarrier();

    if (workgroup_id == 0){
        let cnt = op_reduce.workgroup_count;
        //Finnaly Sum of all worker threads:

        switch(op_reduce.operation){
            case 0u{ //sum
                var sum = ZERO;
                for (var i = 0u; i < cnt; i++){
                    sum +=  sharedSums[i];
                }
                v_dest[output_index] = sum;
            }
            case 1u{ //min
                var sum = sharedSums[0];
                for (var i = 0u; i < cnt; i++){
                    sum = min(sum, sharedSums[i]);
                }
                v_dest[output_index] = sum;
            }
            case 2u{ //max
                var sum = sharedSums[0];
                for (var i = 0u; i < cnt; i++){
                    sum = max(sum, sharedSums[i]);
                }
                v_dest[output_index] = sum;
            }
            default{

            }
        }
    }
}


@compute
@workgroup_size(64,1,1)
fn reduce_index(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let workgroup_id = global_id.x;
    let output_index = global_id.y;
    
    //Start Index of the Elements to Reduce

    var start_index = 0u;// = output_index * op_reduce.output_to_start_stride1 + (output_index / op_reduce.output_to_start_shape_stride2) * op_reduce.output_to_start_stride2;
    if op_reduce.output_to_start_shape_stride2 <= 1
    {
        start_index = output_index * op_reduce.output_to_start_stride1;
    }
    else{
        start_index = output_index * op_reduce.output_to_start_stride1 + (output_index / op_reduce.output_to_start_shape_stride2) * op_reduce.output_to_start_stride2;
    }
    
    let length = op_reduce.length; //length of the elements to reduce

    //We split the Reduction into 64 threads -> find the sub region we need to reduce over 
    let start = workgroup_id * op_reduce.workgroup_size;
    let end = min(length, (workgroup_id + 1) * op_reduce.workgroup_size);

    //Now Reduce from start to end
    switch(op_reduce.operation){
        case 3u{//ArgMin
            var sum = v_input1[get_index(op_reduce.input_layout, start_index).id];
            var arg_index = 0u;
            for (var i = start + 1; i < end; i++){
                let index = get_index(op_reduce.input_layout, start_index + i * op_reduce.stride_reduction).id;
                 if v_input1[index] < sum{
                    sum = v_input1[index];
                    arg_index = i;
                }
            }
            sharedSums[workgroup_id] = sum;    
            sharedIndex[workgroup_id] = arg_index;
        }
        case 4u{//ArgMax
            var sum = v_input1[get_index(op_reduce.input_layout, start_index).id];
            var arg_index = 0u;
            for (var i = start + 1; i < end; i++){
                let index = get_index(op_reduce.input_layout, start_index + i * op_reduce.stride_reduction).id;
                 if v_input1[index] > sum{
                    sum = v_input1[index];
                    arg_index = i;
                }
            }
            sharedSums[workgroup_id] = sum;    
            sharedIndex[workgroup_id] = arg_index;
        }
        default{

        }
    }
    
    workgroupBarrier();

    if (workgroup_id == 0){
        let cnt = op_reduce.workgroup_count;
        //Finnaly Sum of all worker threads:
        

        switch(op_reduce.operation){
            case 3u{//ArgMin
                var sum = sharedSums[0];
                var index = 0u;
                for (var i = 0u; i < cnt; i++){
                    if sharedSums[i] < sum{
                        sum = sharedSums[i];
                        index = i;
                    }
                }
                v_dest_u32[output_index] = sharedIndex[index];
            }
            case 4u{//ArgMax
                var sum = sharedSums[0];
                var index = 0u;
                for (var i = 0u; i < cnt; i++){
                    if sharedSums[i] > sum{
                        sum = sharedSums[i];
                        index = i;
                    }
                }
                v_dest_u32[output_index] = sharedIndex[index];
            }
            default{

            }
        }
    }
}
