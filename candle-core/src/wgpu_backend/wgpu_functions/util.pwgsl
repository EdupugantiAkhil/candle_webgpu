#ifdef f32
#define DTYPE f32 
#endif

#ifdef u32
#define DTYPE u32 
#endif

#ifdef u8
#define DTYPE u32 
#endif

@group(0) @binding(0)
var<storage, read_write> v_dest: array<DTYPE>;

@group(0) @binding(1)
var<storage> op_meta : array<u32>;

@group(0) @binding(2)
var<storage> v_input1: array<DTYPE>;

@group(0) @binding(3)
var<storage> v_input2: array<DTYPE>;

@group(0) @binding(4)
var<storage> v_input3: array<DTYPE>;

@group(0) @binding(0)
var<storage, read_write> v_dest_u32: array<u32>;

@group(0) @binding(0)
var<storage, read_write> v_dest_f32: array<f32>;

@group(0) @binding(2)
var<storage> v_input1_u32: array<u32>;


const ZERO : DTYPE = 0;
const ONE : DTYPE = 1;

#ifdef f32
const MINVALUE : f32 = -3.40282e+38;
#else
const MINVALUE : DTYPE = 0;
#endif



//Layout Information
// struct MatrixLayout{
//     shape1 : u32, 
//     shape2 : u32, 
//     shape3 : u32, 
//     shape4 : u32, 
//     shape5 : u32, 
//     stride1 : u32, 
//     stride2 : u32, 
//     stride3 : u32, 
//     stride4 : u32, 
//     stride5 : u32, 
//     offset : u32,
//     length : u32, //length if contiguous, else 0 
// }

struct MatrixIndex{
    id : u32,
    is_valid : bool
}

// fn get_index(l : MatrixLayout, index : u32) -> MatrixIndex{
//     if l.length != 0{ //Contiguous memory:
//         if index < l.length{
//             return MatrixIndex((l.offset + index), true);
//         }
//         return MatrixIndex(0, false);
//     }
//     else { //not contiguous:
//         let shapes1 = l.shape5;
//         let shapes2 =  (shapes1 * l.shape4);
//         let shapes3 =  (shapes2 * l.shape3);
//         let shapes4 =  (shapes3 * l.shape2);
//         let shapes5 =  (shapes4 * l.shape1);
       
//         let s1 = (index / shapes4);
//         let s2 = (index / shapes3) % (shapes4 / shapes3);
//         let s3 = (index / shapes2) % (shapes3 / shapes2);
//         let s4 = (index / shapes1) % (shapes2 / shapes1);
//         let s5 = index             % (shapes1);

//         let new_index = l.offset + s1 * l.stride1 + s2 * l.stride2 + s3 * l.stride3 + s4 * l.stride4 + s5 * l.stride5;
//          return MatrixIndex(new_index, true);
//     }
// }


fn get_index(input_offset : u32, index : u32) -> MatrixIndex{
    let dims = op_meta[input_offset];
    let start_offset = op_meta[input_offset + 1];
    let length = op_meta[input_offset + 2]; 

    //contigues:
    if(length > 0){
        if index < length{
            return MatrixIndex((start_offset + index), true);
        }
        return MatrixIndex(0, false);
    }

    let start_shape_offset = input_offset + 3;

    var shapes_i = 1u;
    var new_index = start_offset;    
    for (var i2 : i32 = i32(dims) - 1; i2 >= 0; i2--){
        let i = u32(i2);
        let prev_shapes_i = shapes_i;
        shapes_i *= op_meta[start_shape_offset + i]; 

        let si = (index / prev_shapes_i) % (shapes_i / prev_shapes_i);  
        new_index += si * op_meta[start_shape_offset + dims + i]; //s_i * stride_i
    }

    if index >= shapes_i{ //in shapes_i is the length after the for loop
        return MatrixIndex(0, false);
    }

    return MatrixIndex(new_index, true);
}

fn get_size(input_offset : u32) -> u32{
    let dims = op_meta[input_offset];
    return dims * 2 + 3;
}